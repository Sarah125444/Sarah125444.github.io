<!DOCTYPE HTML>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content="正则表达式">


    <meta name="description" content="正则表达式字符匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。
两种模糊匹配如果正则只有精确匹配是没有多大意义的，比如/hello/，只能匹配字符串中的hello这个子串
1234&l...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>正则表达式（一） | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 忙人的养猪综合指南 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>笔记</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>日常</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="正则表达式（一）">
            
	            正则表达式（一）
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/正则表达式/">正则表达式</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/07/31</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="正则表达式字符匹配攻略"><a href="#正则表达式字符匹配攻略" class="headerlink" title="正则表达式字符匹配攻略"></a>正则表达式字符匹配攻略</h2><p><strong>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</strong></p>
<h3 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h3><p>如果正则只有精确匹配是没有多大意义的，比如/hello/，只能匹配字符串中的hello这个子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type= &quot;xx&quot; id=&quot;001&quot;&gt;</span><br><span class="line">var regex = /hello/;</span><br><span class="line">console.log(regex.test(&quot;hello&quot;)); //true</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>正则之所以强大，是因为能够实现模糊匹配<br>而模糊匹配，有两个方向上的模糊：横向模糊和纵向模糊</p>
<h4 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h4><ul>
<li>横向模糊指的是，一个正则可匹配的字符串的长度是不固定的，可以是多种情况<br>其实现的方式是使用量词，譬如{m,n},表示连续出现最少m次，最多n次。<br>比如：/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”,接下来是2到5个字符“b”,最后是子父”c”.<br>测试如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type= &quot;x&quot; id=&quot;002&quot;&gt;</span><br><span class="line">    var regex = /ab&#123;2,5&#125;c/g;</span><br><span class="line">    var string = &quot;abc abbc abbbc abbbbbc abbbbbbc&quot;</span><br><span class="line">    console.log(string.match(regex)); //[0: &quot;abbc&quot;  1: &quot;abbbc&quot; 2: &quot;abbbbbc&quot;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意：案例中用的正则是/ab{2,5}c/g,后面多了g,它是正则的一个修饰符，表示全局匹配。<br>即在目标字符串中按顺序找到满足匹配模式的所有字串。强调的是“所有”，而不是“第一个”。<br>g是单词global的首字母。</p>
<h4 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h4><ul>
<li>纵向模糊匹配指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。<br>其实现的方式是使用字符串。譬如：[abc],表示该字符是可以字符 “a” “b” “c”中的任何一个。<br>比如：/a[1,2,3]b/可以匹配如下三种字符串，”a1b” “a2b” “a3b” 测试如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;x&quot; id=&quot;003&quot;&gt; </span><br><span class="line">var regex = /a[123]b/g;</span><br><span class="line">var string = &quot;a0b a1b a2b a3b a4b&quot;</span><br><span class="line">console.log(string.match(regex)); //[&quot;a1b&quot;  &quot;a2b&quot;  &quot;a3b&quot;]</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>需要强调的是，虽然叫字符组（字符组），但是只是其中一个字符。例如[abc],表示匹配一个字符，它可以是”a” ，”b”， “c”之一。</p>
<h4 id="范围表示法"><a href="#范围表示法" class="headerlink" title="范围表示法"></a>范围表示法</h4><p>如果字符组的字符特别多的话，怎么办？可以用范围表示法。<br>比如[123456abcdefaGHIJKLM],可以写成[1-6a-fG-M].用连字符来省略和简写。<br>因为连字符有特殊用途，那么要匹配的”a”,”-“,”z”这三者中的任意一个字符，该怎么做呢？<br>不能写成[a-z],因为其表示小写字符中的任何一个字符。<br>可以写成如下的方式：[-az]或[az-]或[z-z]。即要么放在开始，要么放在结尾，要么转译，总之不会让引擎认为是范围表示法就好了。</p>
<h4 id="排除字符组"><a href="#排除字符组" class="headerlink" title="排除字符组"></a>排除字符组</h4><p>纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是”a”,”b”,”c”。<br>此时就是排除字符组（反义字符组）的概念。例如[^abc]，表示是一个除”a”,”b”,”c”之外的任意一个字符。字符组的第一位放在^（脱字符），表示求反的意思。<br>当然，也有相应的返回表示法。</p>
<h4 id="常见的简写形式"><a href="#常见的简写形式" class="headerlink" title="常见的简写形式"></a>常见的简写形式</h4><p>有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d就是[0-9] 表示的是一位数字。记忆方式是digit(数字)</span><br><span class="line">\D就是[^0-9] 表示除数字外的任意字符</span><br><span class="line">\w就是[0-9a-zA-Z]。表示数字、大小写字母和下划线。</span><br><span class="line">\W是[^0-9a-zA-Z_] 非单词字符</span><br><span class="line">\s是[ \t\v\n\r\f]表示空白符，包括空格，水平制表符，垂直制表符，换行符，回车符，回车符，换页符。记忆方式：s是space character的首字母。</span><br><span class="line">\S是[^ \t\v\n\r\f] 非空白符</span><br><span class="line">.就是[^\n\r\u2028\u2029] 通配符，表示几乎任意字符，换行符，回车符，行分割符和段分隔符除外。</span><br></pre></td></tr></table></figure>

<p>如果要匹配任意字符怎么办？可以使用[\d\D]，[\w\W],[\s\S]和[^]中任何一个。</p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词也称重复。掌握{m,n}的准确定义后，只需要记住一些简写形式。</p>
<h4 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;m,&#125; 表示至少出现m次</span><br><span class="line">&#123;m&#125;等价于&#123;m,m&#125;，表示出现m次</span><br><span class="line">？等价于&#123;0,1&#125;,表示出现或者不出现。</span><br><span class="line">+ 等价于&#123;1,&#125;,表示至少出现一次。</span><br><span class="line">* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。</span><br></pre></td></tr></table></figure>

<h4 id="贪恋模式和惰性匹配"><a href="#贪恋模式和惰性匹配" class="headerlink" title="贪恋模式和惰性匹配"></a>贪恋模式和惰性匹配</h4><p>看如下的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;/g;</span><br><span class="line">var string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); //[&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;]</span><br></pre></td></tr></table></figure>

<p>其中正则/\d{2,5}/,表示数字连续出现2到5次，会匹配2位，3位，4位，5位连续数字。<br>但是其是贪恋的，它会尽可能多的匹配。你给我6个，我就要5个。你能给我3个，我就要3个。反正只要在能力范围内，越多越好。</p>
<p>惰性匹配就是尽可能少的匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;?/g;  </span><br><span class="line">var string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); // =&gt; [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;]</span><br></pre></td></tr></table></figure>

<p>其中/\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不往下尝试了。<br>通常在量词后面加个问号就能实现，因此所有惰性匹配情形如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;m,n&#125;?</span><br><span class="line">&#123;m,&#125;?</span><br><span class="line">??</span><br><span class="line">+?</span><br><span class="line">*?</span><br></pre></td></tr></table></figure>

<p>对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪恋吗？</p>
<h3 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h3><p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。<br>具体形式如下：(p1|p2|p3),其中p1、p2和p3是子模式，用|（管道符）分割，表示其中任何之一。<br>例如要匹配”good”和”nice”可以使用/good|nice/.测试如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|nice/g;</span><br><span class="line">var string = &quot;good idea,nice try.&quot;;</span><br><span class="line">console.log(string.match(regex)); //// =&gt; [&quot;good&quot;, &quot;nice&quot;]</span><br></pre></td></tr></table></figure>

<p>但是有个事实我们应该注意，比如我用/good|goodbye/，去匹配”goodbye”字符串时，结果是”good”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|goodbye/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log(string.match(regex)); // =&gt; [&quot;good&quot;]</span><br></pre></td></tr></table></figure>

<p>而把正则改成/goodbye|good/，结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /goodbye|good/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log(string.match(regex)); // =&gt; [&quot;goodbye&quot;]</span><br></pre></td></tr></table></figure>

<p>也就是说，分支结构是惰性结构，即当前面的匹配上了，后面的就不再尝试了。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。<br>下面找几个例子演绎一下（其中，每个正则并不是唯一写法）：</p>
<h4 id="匹配16进制颜色值"><a href="#匹配16进制颜色值" class="headerlink" title="匹配16进制颜色值"></a>匹配16进制颜色值</h4><p>要求匹配：</p>
<p> #ffbbad #Fc01DF #FFF #ffE<br> 分析：表示一个16进制字符，可以用字符组[0-9a-fA-F],<br> 其中字符可以出现3或6次，需要是用量词和分支结构。<br> 使用分支结构时，需要注意顺序。<br> 正则如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line">var string = &quot;#ffbbad #Fc01DF #FFF #ffE&quot;;</span><br><span class="line">console.log(string.match(regex)); // =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;]</span><br></pre></td></tr></table></figure></p>
<p> 匹配时间：<br> 以24小时制为例<br> 要求匹配：<br> 23:59<br> 02:07<br> 分析：<br> 共4位数字，第一位数字可以为[0,2];<br> 当第一位为2时，第2位可以为[0-3],其他情况下，第2位为[0-9];<br> 第3位数字为[0-5],第4位为[0 - 9];<br> 正则如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;</span><br><span class="line">console.log(regex.test(&quot;23:59&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;02:07&quot;)); //true</span><br></pre></td></tr></table></figure>

<p> 如果要求匹配7:9，也就是说时分前面的0可以忽略；<br> 此时正则表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;</span><br><span class="line">console.log(regex.test(&quot;23:59&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;02:07&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;7:9&quot;)); //true</span><br></pre></td></tr></table></figure>

<h4 id="匹配日前"><a href="#匹配日前" class="headerlink" title="匹配日前"></a>匹配日前</h4><p>比如yyyy-mm-dd格式为例<br>要求匹配：2017-06-10<br>分析：</p>
<ul>
<li>年：四位数字即可，可用[0-9]{4}</li>
<li>月：共12个月，分两种情况01、02、……、09和10、11、12，可用(0[1-9]|1[0-2])</li>
<li>日：最大31天，可用(0[1-9]|[12][0-9]|3[01])<br>正则如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line">console.log(regex.test(&quot;2017-06-10&quot;)); //true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="window操作系统文件路径"><a href="#window操作系统文件路径" class="headerlink" title="window操作系统文件路径"></a>window操作系统文件路径</h4><p>要求匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F:\study\javascript\regex\regular expression.pdf</span><br><span class="line">F:\study\javascript\regex\</span><br><span class="line">F:\study\javascript</span><br><span class="line">F:\</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>整体模式是：</p>
<ul>
<li>盘符：\文件夹\文件夹\文件夹\</li>
<li>其中匹配F:,需要使用[a-zA-Z]:\,其中盘符不区分大小写，注意\字符需要转义。</li>
<li>文件名或者文件夹名字，不能包含一些特殊字符，此时我们需要排除字符组[^\:*&lt;&gt;|”?\r\n/]来表示合法字符。</li>
<li>另外不能为空名，至少有一个字符，也就是需要使用量词+。因此匹配”文件夹&quot;,可以用[^\:*&lt;&gt;|”?\r\n/]+\。</li>
<li>另外“文件夹”，可以出现任意次，也就是([^\:*&lt;&gt;|”?\r\n/]+\)*。其中括号提供子表达式。</li>
<li>路径的最后一部分可以是“文件夹”，没有,因此需要添加([^\:*&lt;&gt;|”?\r\n/]+)?。<br>最后拼接了一个看起来比较复杂的正则。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/;</span><br><span class="line">console.log(regex.test(&quot;F:\\study\\javascript\\regex\\regular expression.pdf&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;F:\\study\\javascript\\regex\\&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;F:\\study\\javascript&quot;)); //true</span><br><span class="line">console.log(regex.test(&quot;F:\\&quot;)); //true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中，JS中字符串表示\时，也要转义。</p>
<h4 id="匹配id"><a href="#匹配id" class="headerlink" title="匹配id"></a>匹配id</h4><p>要求从</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;div&gt;</span><br></pre></td></tr></table></figure>

<p>提取出id=”container”;<br>可能最开始想到的正则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;.*&quot;/;</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]); //id=&quot;container&quot; class=&quot;main&quot;</span><br></pre></td></tr></table></figure>

<p>因为.是通配符，本身就是匹配双引号的，而量词*又是贪婪的，当遇到container后面双引号时，不会停下来，会继续匹配，直到遇到最后一个双引号为止。<br>解决之道，可以使用惰性匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;.*?&quot;/;</span><br><span class="line">var string=&apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]); //id=&quot;container&quot;</span><br></pre></td></tr></table></figure>

<p>当然这也会有个问题，效率会比较低，因为其匹配原理会涉及到“回溯”这个概念。可以优化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /id=&quot;[^&quot;]*&quot;/;</span><br><span class="line">var string = &apos;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;div&gt;&apos;;</span><br><span class="line">console.log(string.match(regex)[0]); //id=&quot;container&quot;</span><br></pre></td></tr></table></figure>


    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/07/31/正则表达式2/" class="pre-post btn btn-default" title='正则表达式（二）'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">正则表达式（二）</span>
        </a>
    
    
        <a href="/2019/07/30/hello-world/" class="next-post btn btn-default" title='Hello World'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Hello World</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式字符匹配攻略"><span class="toc-text">正则表达式字符匹配攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两种模糊匹配"><span class="toc-text">两种模糊匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#横向模糊匹配"><span class="toc-text">横向模糊匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#纵向模糊匹配"><span class="toc-text">纵向模糊匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符组"><span class="toc-text">字符组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#范围表示法"><span class="toc-text">范围表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排除字符组"><span class="toc-text">排除字符组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的简写形式"><span class="toc-text">常见的简写形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#量词"><span class="toc-text">量词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简写形式"><span class="toc-text">简写形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#贪恋模式和惰性匹配"><span class="toc-text">贪恋模式和惰性匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多选分支"><span class="toc-text">多选分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例分析"><span class="toc-text">案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配16进制颜色值"><span class="toc-text">匹配16进制颜色值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配日前"><span class="toc-text">匹配日前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window操作系统文件路径"><span class="toc-text">window操作系统文件路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配id"><span class="toc-text">匹配id</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>